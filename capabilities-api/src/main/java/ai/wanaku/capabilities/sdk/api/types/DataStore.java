package ai.wanaku.capabilities.sdk.api.types;

import java.util.Objects;

/**
 * Entity representing a data store entry for persisting arbitrary binary or text data.
 *
 * <p>DataStore provides a generic storage mechanism for files, configurations, or any other
 * content that needs to be stored and retrieved through the Wanaku API. The data is typically
 * stored as Base64-encoded content to safely handle binary files and special characters.
 *
 * <p><b>Usage Example:</b>
 * <pre>{@code
 * // Creating a new data store entry
 * DataStore dataStore = new DataStore();
 * dataStore.setName("config.yaml");
 * dataStore.setData(Base64.getEncoder().encodeToString(fileBytes));
 * dataStore.addLabel("environment", "production");
 *
 * // The ID will be automatically assigned by the persistence layer
 * }</pre>
 *
 * <p><b>Storage Format:</b>
 * <ul>
 *   <li>Data is persisted in Infinispan distributed cache</li>
 *   <li>Content is typically Base64-encoded for safe binary storage</li>
 *   <li>Multiple entries can share the same name but will have unique IDs</li>
 *   <li>Supports labels for categorization and filtering</li>
 * </ul>
 *
 * @see LabelsAwareEntity
 * @see WanakuEntity
 */
public class DataStore extends LabelsAwareEntity<String> {

    /**
     * Unique identifier for this data store entry.
     * Automatically generated by the persistence layer when the entry is created.
     */
    private String id;

    /**
     * Human-readable name for this data store entry.
     * Typically represents the original filename or a descriptive label.
     * Multiple data stores can share the same name.
     */
    private String name;

    /**
     * The stored content, typically Base64-encoded.
     * This field contains the actual data payload, which is usually encoded
     * to safely handle binary files and special characters.
     */
    private String data;

    /**
     * Default constructor required for serialization/deserialization.
     */
    public DataStore() {}

    /**
     * Constructs a DataStore with all fields initialized.
     *
     * @param id the unique identifier for this data store entry
     * @param name the human-readable name for this entry
     * @param data the content to store (typically Base64-encoded)
     */
    public DataStore(String id, String name, String data) {
        this.id = id;
        this.name = name;
        this.data = data;
    }

    /**
     * Returns the unique identifier for this data store entry.
     *
     * @return the ID, or {@code null} if not yet persisted
     */
    @Override
    public String getId() {
        return id;
    }

    /**
     * Sets the unique identifier for this data store entry.
     * Typically called by the persistence layer.
     *
     * @param id the unique identifier
     */
    @Override
    public void setId(String id) {
        this.id = id;
    }

    /**
     * Returns the human-readable name of this data store entry.
     *
     * @return the name, typically representing the filename or label
     */
    public String getName() {
        return name;
    }

    /**
     * Sets the human-readable name for this data store entry.
     *
     * @param name the name to set (e.g., filename or descriptive label)
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Returns the stored content data.
     *
     * @return the data content, typically Base64-encoded
     */
    public String getData() {
        return data;
    }

    /**
     * Sets the content data to be stored.
     *
     * <p>The data should typically be Base64-encoded when storing binary files
     * or content with special characters. For example:
     * <pre>{@code
     * byte[] fileBytes = Files.readAllBytes(path);
     * dataStore.setData(Base64.getEncoder().encodeToString(fileBytes));
     * }</pre>
     *
     * @param data the content to store (typically Base64-encoded)
     */
    public void setData(String data) {
        this.data = data;
    }

    /**
     * Compares this DataStore to another object for equality.
     * Two DataStore instances are considered equal if they have the same id, name, data, and labels.
     *
     * @param o the object to compare with
     * @return {@code true} if the objects are equal, {@code false} otherwise
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DataStore dataStore = (DataStore) o;
        return Objects.equals(id, dataStore.id)
                && Objects.equals(name, dataStore.name)
                && Objects.equals(data, dataStore.data)
                && Objects.equals(getLabels(), dataStore.getLabels());
    }

    /**
     * Returns a hash code value for this DataStore.
     * The hash code is computed based on the id, name, data, and labels fields.
     *
     * @return a hash code value for this object
     */
    @Override
    public int hashCode() {
        return Objects.hash(id, name, data, getLabels());
    }

    /**
     * Returns a string representation of this DataStore.
     * The string includes the id, name, data, and labels fields.
     *
     * @return a string representation of this DataStore
     */
    @Override
    public String toString() {
        return "DataStore{"
                + "id='" + id + '\''
                + ", name='" + name + '\''
                + ", data='" + data + '\''
                + ", labels=" + getLabels()
                + '}';
    }
}
